В лабораторной работе № 5 отлаженный модуль списка используется
как абстрактный уровень решаемой задачи. Создается новый модуль,
содержащий реализацию предметно-ориентированного уровня, и его
заголовочный файл (например subj.cpp и subj.h). Алгоритмы
обработки списка (печать, сортировка, поиск и т.п.) должны быть
реализованы как методы класса (например, SubjList), производного
от класса списка List. Собственно классы элементов, предписанных
заданием, должны являться потомками некоторого базового класса
(Base), который, в свою очередь, является производным от класса
элемента списка Item.

 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
                                                абстрактный
   +----------+                  +----------+   уровень "список"
   |   List   | - - - - - - - -> |   Item   |
   +----------+    использует    +----------+
        ^                             ^
        |                             |
 . . . .|. . . . . . . . . . . . . . .|. . . . . . . . . . . .
        |                             |         предметно-
        |                             |         ориентированный
        |                             |         уровень "базовый"
        |                             |
        | наследует от                | наследует от
   +----------+                  +----------+
   | SubjList | - - - - - - - -> |   Base   |
   +----------+    использует    +----------+
                                      ^
 . . . . . . . . . . . . . . . . . . .|. . . . . . . . . . . .
                                      |         специфический
                                      |         уровень
                                      |
                         наследуют от |
               +---------------+------+-----------+
               |               |                  |
          +----------+    +----------+       +----------+
          | Потомок1 |    | Потомок2 |  ...  | ПотомокN |
          +----------+    +----------+       +----------+

 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

В базовом классе Base должны быть описаны все общие элементы его
потомков - как поля данных, так и методы, представляющие собой
унифицированный интерфейс. Эти операции над объектами конечных
классов (такие как методы ввода и вывода значений полей объекта,
отыскание отдельных характеристик объектов, используемых при
сортировке и поиске) реализуются посредством диспетчеризации.

Так как объекты разных классов имеют различные наборы полей, то
ввод их значений с клавиатуры и их вывод на экран должны быть
выполнены в методах соответствующих классов-потомков. В методах
базового класса должна быть реализована диспетчеризация, т.е.
определяется фактический тип объекта, выполняется соответствующее
как в лабораторной работе № 3, но приведение типа должно
применяться к указателю this (понижающее преобразование) и затем
вызывается требуемый специфический метод класса-потомка. Для
примера рассмотрим реализацию печати объекта (метод Print):

SUBJ.H
------
  ...
  enum ItemType { itDog = 1, itCat, itCrocodile };

  class Base : public Item
  {
    ItemType type;
    ...
  public:
    void Print(void);             // РАЗ - объявляем интерфейс
    ...
  };

  class SubjList : public List
  {
    ...
  public:
    void Print(void);
    ...
  };


SUBJ.CPP
--------

  #include "subj.h"

  class Dog : public Base
  {
    ...
  public:
    void Print(void);           // ДВА - объявляем спец. метод
    ...                         //        в классе-потомке
  };

  class Cat ...          // аналогично ДВА
  class Crocodile ...    // аналогично ДВА

  ...

  void SubjList::Print(void)
  {
    for (Base * p = (Base*) Head(); p; p = (Base*) p->Next())
      p->Print();
  }

  ...

  void Base::Print(void)         // ТРИ - диспетчеризация
  {
    switch (type)                           // ты кто?
    {
      case itCrocodile:                     // крокодил!
        ((Crocodile*) this)->Print();       // тогда сюда
        break;

      ...          // аналогично другие типы

      default:     // неизвестный питомец
        printf("Кто я?!");  // сам не знает - его проблемы
        break;
    }
  }

  ...

  void Crocodile::Print(void)   // ЧЕТЫРЕ - реализация спец.
  {                             //             метода
    printf("Я злой и страшный Crocodile!\n"
           "И поля у меня тоже какие-то есть.\n");
  }

Обратите внимание, что и в базовом классе Base, и в производных
от него классах-потомках Dog, Cat и Crocodile определены методы
Print(), полностью совпадающие по сигнатуре (имени и списку
формальных параметров). Методы потомков в этом случае скрывают
одноименный метод предка, но при вызове метода его отыскание
(см. раздел лекций "Класс как область действия") начинается в
том классе, которому соответствует указатель на объект, а не
фактический тип объекта. В примере выше, вызов p->Print() в
методе SubjList::Print() приведет к вызову именно метода
Base::Print(), т.к. указатель p имеет тип Base*. Но на самом
деле объект будет принадлежать одному из классов потомков - Dog,
Cat или Crocodile, и мы хотели бы вызвать его специфический
метод.

Чтобы в методе класса-предка вызвать какой-либо метод класса-
потомка, необходимо указатель this привести к требуемому типу,
т.е. вызвать "свой" метод как бы извне, как для другого объекта
другого типа. Например, в выражении, приведенном выше, this
имеет тип Base*, т.к. используется в методе класса Base. В целом
это выражение интерпретируется так:

        ( (Crocodile *) this ) -> Print()
        \              \____/           /
         \              Base*          /
          \_________________/         /
                Crocodile*           /
               \____________________/
                 Crocodile::Print()

Требуемый тип, т.е. реальный тип объекта, мы определяем по
значению поля type также, как в лабораторной работе № 3.

Вот и вся диспетчеризация. А в главной функции по-прежнему
будет:

  L.Print();

А на экран вместо указателей полезут собаки, крокодилы...

Аналогично рассмотренному, реализуются и другие методы, в частности,
сортировка объектов подразумевает сравнение значений какой-либо их
характеристики. Если алгоритм отыскания этого значения различен для
объектов разных типов, то для сравнения объектов друг с другом
должен использоваться один из следующих методов:
  - метод, вызываемый для одного объекта и принимающий второй
    объект (указатель на него) в качестве параметра;
  - метод, возвращающий значение той характеристики объекта, по
    которой выполняется сортировка.
При этом в соответствующем методе базового класса реализуется
диспетчеризация, а собственно сравнение значений или отыскание
(вычисление) требуемого значения выполняется в специфических
методах классов-потомков, т.е. в зависимости от фактических типов
сравниваемых объектов.

Кроме того, поиск объектов предполагает сравнение значения
определенного поля с некоторым значением, что также, как и сравнение
двух объектов при сортировке, удобно реализовать в виде специального
метода и здесь тоже может потребоваться диспетчеризация.

З.Ы. Если возникнет необходимость в теле метода класса-потомка
вызвать какой-либо метод класса-предка, скрытый в потомке
одноименным методом, то необходимо использовать операцию
видимости.
