В данной работе требуется создать иерархию классов,
соответствующую индивидуальному заданию. В общем виде она
будет иметь такой вид:

 . . . . . . . . . . . . . . . . . . . . . . . . .
                                    абстрактный
                     +----------+   уровень "список"
                     |   Item   |
                     +----------+
                          ^
                         /_\
 . . . . . . . . . . . . .|. . . . . . . . . . . .
                          |         предметно-
                          |         ориентированный
                          |         уровень "базовый"
            наследует от  |
                     +----------+
                     |   Base   |
                     +----------+
                          ^
                         /_\
 . . . . . . . . . . . . .|. . . . . . . . . . . .
                          |         специфический
                          |         уровень
            наследуют от  |
       +---------------+--+---------------+
       |               |                  |
  +----------+    +----------+       +----------+
  | Потомок1 |    | Потомок2 |  ...  | ПотомокN |
  +----------+    +----------+       +----------+

 . . . . . . . . . . . . . . . . . . . . . . . . .


Наследование при помощи структур имитировать просто, если
известно, что поля структуры располагаются в памяти строго
в том порядке, в каком они описаны. Следовательно, если
описание нескольких первых полей в двух структурах
совпадает, то в этой части эти две структуры будут
абсолютно идентичны.

Отсюда простой вывод: описывая структуру Base, в качестве
первых полей копируем и вставляем все поля из структуры
Item, а затем (ниже их!) дописываем описания "своих" полей.
Описывая каждую из специфических структур, в качестве
первых полей также копируем и вставляем все поля из структуры
Base, так как она является предком для них, а затем (ниже
скопированных полей) дописываем описания "своих" полей,
специфических для каждого конечного типа потомка.

Например, список хранит информацию о домашних питомцах. Тогда
структура Base соответствует "обобщенному" питомцу и содержит
поля, общие для питомцев всех видов, а потомки описывают
конкретные биологические виды. Таким образом, унаследованные
поля в структуре-потомке будут располагаться в памяти так же,
как в структуре-предке, относительно адреса объекта:

 Item        Base          Cat         Dog         Crocodile
 +-------+...+-------+.....+-------+...+-------+...+-------+
 |next   |   |next   |     |next   |   |next   |   |next   |
 |prev   |   |prev   |     |prev   |   |prev   |   |prev   |
 +-------+...+-------+     |.......|   |.......|   |.......|
             |type   |     |type   |   |type   |   |type   |
             |nick   |     |nick   |   |nick   |   |nick   |
             |age    |     |age    |   |age    |   |age    |
             +-------+.....+-------+...+-------+...+-------+
                           |wool   |   |weight |   |lenght |
                           |furage |   |service|   |area   |
                           |colour |   |breed  |   +-------+
                           +-------+   +-------+
\_____________________/   \_________________________________/
         предки                         потомки

Структура Base представляет объект на базовом предметно-
ориентированном уровне. С точки зрения использования этого
семейства классов, все объекты будут представлены именно
этими структурами, а специфические поля структур-потомков
"спрятаны" и обрабатываются специфическими функциями. Однако,
для этого необходимо, чтобы структура Base позволяла
идентифицировать фактический тип объекта. Для этого
целесообразно описать перечисление, определяющее уникальное
значение для каждого типа потомка, и ввести в базовую
структуру поле, хранящее это значение (поле type):

  struct Item
  {
    struct Item * next;
    struct Item * prev;
  };

  enum ItemType { itNone, itCat, itDog, itCrocodile };

  struct Base
  {
    /* унаследовано от Item - просто скопировано как есть! */
    struct Item * next;
    struct Item * prev;
    /* добавлено в Base */
    enum ItemType type;
    char nick[20];
    int age;
  };

Эти описания помещаются в заголовочном файле предметно-
ориентированного модуля. В самом модуле подключается
заголовочный файл и описываются структуры-потомки.
Унаследованная часть структуры-предка (все ее поля) просто
копируется из ее описания и вставляется в описание структур-
потомков, чтобы обеспечить абсолютную идентичность. Затем 
описываются специфические поля:

  #include "subj.h"

  struct Cat
  {
    /* унаследовано от Item */
    struct Item * next;
    struct Item * prev;
    /* унаследовано от Base */
    enum ItemType type;
    char name[20];
    int age;
    /* добавлено в Cat */
    int wool;
    char furage[50];
    char colour[30];
  };

Аналогично описываются структуры Dog и Crocodile.

Внимание!!! После того, как структуры будут описаны, крайне
желательно предъявить результаты этой части работы
преподавателю, чтобы убедиться, что задание понято верно и
впоследствии не придется переделывать большую часть работы.
