Для того, чтобы некоторую группу функций было удобно использовать
при создании нескольких программ, их выделяют в отдельный модуль,
например как в лабораторной работе № 2. Модуль - это физическая
единица программы, отдельный файл исходного кода, который и
компилируется отдельно от других модулей. Таким образом
организованы библиотеки, как стандартные, так и разрабатываемые
программистами для собственных нужд.

В ходе лабораторной работы № 1 были реализованы функции для работы
с динамическим списком элементов и описаны соответствующие типы
данных (структуры списка и элемента). Для отладки этих функций
потребовалась реализация главной функции программы, функции вывода
списка на экран и, возможно, некоторых других функций. Эти функции,
необходимые только для отладки списка, не будут нужны в дальнейшем,
при использовании списка для решения каких-либо задач. В
последующих работах потребуются только описания структур и 8
функций для обработки списка, которые целесообразно реализовать в
виде отдельного модуля и использовать почти так же, как
стандартные библиотеки.

Любой модуль, кроме головного, состоит, как правило, из двух
частей - интерфейса и реализации. Интерфейсом модуля является его
заголовочный файл, который содержит только описания типов данных
и объявления функций и глобальных переменных, которые определены
в файле реализации модуля и должны быть доступны извне. Файлы
интерфейса модуля в языках C/C++ имеют расширение .h и называются
заголовочными. Файлы реализации модуля обычно называют просто
модулями и они имеют расширение .c и .cpp для языков C и C++
соответственно.

В лабораторной работе № 2 требуется создать модуль списка, который
содержит описания структур списка и элемента, объявления и
определения функций для работы со списком: Add, Insert, Remove,
Delete, GetIndex, GetItem, Count и Clear или аналогичных им. Для
этого необходимо:

1. Создать в среде программирования два новых файла (команда меню
   File->New) интерфейса и реализации модуля списка и сохранить
   их (File->Save as) с именами list.h и list.c (имена файлов
   взяты для примера).

2. Из файла программы (л/р № 1) вырезать (Edit->Cut) описания
   типов данных (структуры списка и элемента) и поместить их
   (Edit->Paste) в заголовочный файл list.h.

3. Из файла программы вырезать объявления (прототипы) функций,
   реализующих операции над списком (см. выше), и поместить их в
   заголовочный файл list.h ниже описания структур.

      Примечание. Если эти прототипы не были созданы, то их
      необходимо привести в заголовочном файле в полном
      соответствии с реализацией этих функций.

4. Из файла программы вырезать реализации функций обработки
   списка и вставить в файл реализации модуля списка list.c.
   Прототипы и реализации отладочных функций (т.е. тех, которые
   не потребуются при решении каких-либо прикладных задач)
   переносить в модуль списка не нужно!

5. Подключить заголовочный файл модуля списка list.h директивой
   #include в файле самого модуля list.c, что позволит компилятору
   контролировать правильность использования структур списка и
   элемента, реализаций и вызовов функций. Также подключить
   заголовочный файл модуля в файле исходной программы, который
   теперь является головным модулем.

      Примечание. В директиве #include имена заголовочных файлов
      стандартных библиотек указываются в угловых кавычках,
      например #include <stdlib.h> (символы "меньше" и "больше"),
      а нестандартных - в двойных, например #include "list.h".
      Такие заголовочные файлы размещаются не в папках библиотек,
      а в текущей папке. Нестандартные заголовочные файлы
      рекомендуется включать после стандартных.

6. Чтобы убедиться в правильности выполненных действий, можно
   скомпилировать каждый модуль отдельно (Alt-F9).

      Примечание. Отдельный модуль не является законченной
      программой и после его компиляции не может быть собран
      исполняемый файл (возникнут ошибки - Linker error).
   
7. Чтобы все-таки скомпилировать эти модули, но получить при этом
   одну программу (т.е. один исполняемый файл, который можно
   запустить), необходимо либо использовать параметры командной
   строки компилятора и редактора связей, либо создать проект.
