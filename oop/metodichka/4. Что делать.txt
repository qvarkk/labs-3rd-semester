В лабораторной работе № 4 необходимо реализовать список в виде
двух классов - элемента списка и собственно списка. Эти классы
должны быть реализованы в виде отдельного модуля (например
list.cpp), имеющего заголовочный файл (например list.h), и
включенного в состав проекта для его отладки (т.е. как в
лабораторной работе № 2). Реализация классов сводится, по сути,
к переводу модуля, уже разработанного на языке C в лабораторных
работах № 1 и 2, на язык C++ с использованием классов вместо
структур и их методов вместо функций, а также операций new и
delete вместо функций динамического распределения памяти.
Алгоритмы работы со списком (добавление, удаление, подсчет и
т.д.) остаются прежними и их реализация не должна существенно
измениться, изменения будут вызваны только различием синтаксиса
языков и приведут, в первую очередь, к упрощению реализации
методов.

С особым вниманием следует отнестись к вопросам безопасности
системы объектов, в частности, желательно (в меру возможностей
и освоенного лекционного материала) разрешить следующие вопросы:

1. Поля-указатели head, tail, next, prev являются уязвимым
   местом, т.к. их изменение, не предусмотренное алгоритмом,
   может привести к разрушению списка, следовательно, эти поля
   не должны быть доступны извне (private). Для эффективной
   реализации итерационных алгоритмов над списком можно
   реализовать в классах List и Item методы Head() и Tail(),
   которые возвращают значения соответствующих полей. Для
   упрощения работы с объектами класса Item в методах класса
   List желательно использовать отношение дружественности
   (friend), если этот материал уже рассмотрен на лекциях или
   освоен самостоятельно.

2. Уничтожение объекта-элемента, включенного в список, может
   привести к разрушению этого списка, т.к. соседние элементы
   будут по-прежнему ссылаться на этот объект даже после того,
   как он перестанет существовать. Поэтому в классе Item
   необходимо реализовать деструктор, который гарантирует
   исключение уничтожаемого элемента из списка, если он в
   списке содержится. Возможный путь решения - включить в
   состав объектов класса Item указатель на объект-владелец
   класса List.

3. Уничтожение объекта-списка, в котором содержатся элементы,
   должно приводить к уничтожению этих элементов, т.к. в
   противном случае они по-прежнему будут занимать память, но
   уже не будут доступны. Для этого необходимо реализовать
   деструктор класса List, выполняющий действия, аналогичные
   методу Clear(), или вызывающий его.

4. Любой объект при его создании должен быть адукватен, т.е.
   список должен быть пустым, а элемент - не содержащимся в
   списке и не имеющим ни предыдущего, ни следующего за ним
   элемента. Поэтому в каждом классе должен быть реализован
   хотя бы один конструктор, инициализирующий поля данных
   объекта соответствующим образом.

5. Даже при отладке списка желательно создать модуль в таком
   виде, в котором он без каких-либо изменений будет
   использоваться в последующих работах. Чтобы не включать в
   состав класса List функции печати списка и др. отладочные
   функции, их реализацию целесообразно выполнить в классе,
   производном от List и реализованном непосредственно в
   модуле main.cpp.

Таким образом, учитывая все эти замечания, в головном модуле
может иметь место примерно такое описание отладочного класса:

   #include "list.h"
   class DebugList : public List
   {
   public:
     void Print(void);
     void Menu(void);
     ... /* др. отладочные и вспом. ф-ции */
   };

Тогда реализация метода печати всего списка может иметь вид:

   void DebugList::Print(void)
   {
     int i;
     Item * p;
     printf("\t#\tp\tp->Next()\n");
     for (p = Head(), i = 0; p; p = p->Next(), i++)
       printf("\t%d\t%p\t%p\n", i, p, p->Next());
   }

Фрагмент главной функции:

   void main(void)
   {
     char c;       // для ввода пункта меню
     Item * p;     // рабочий указатель
     DebugList L;  // объект списка

     do
     {
       L.Menu();   // вывод меню
       c = getch();
       switch (c)
       {
         case 1:   // добавление
           p = new Item();  // создание элемента
           L.Add(p);        // добавление в список
           break;
         ...  // другие команды меню
         case 9:   // вывод списка
           L.Print();
           break;
       }
     }
     while (c != 27); // клавиша ESC - выход
   }
   /* L - стековый объект, поэтому он уничтожится
      автоматически, а его деструктор (если он реализован!)
      обеспечит очистку списка, т.е. уничтожение всех
      элементов */
