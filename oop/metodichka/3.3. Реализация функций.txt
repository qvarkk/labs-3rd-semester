Все операции, которые можно выполнять с объектами, необходимо
реализовать в виде функций. К операциям над объектами относятся:
- ввод и вывод объекта (ввод значений полей с клавиатуры и их
  вывод на экран);
- изменение состояния объекта (присваивание полям объекта новых
  значений, если это предусмотрено заданием);
- чтение характеристик объекта (чтение значений полей или
  вычисление значений).
Кроме того, необходимо реализовать фабричную функцию, которая
создает объект требуемого типа. Также необходимо рализовать
операции над всем списком объектов, такие как вывод всего списка,
вывод объектов, отобранных по определенному критерию (в
соответствии с индивидуальным заданием), сортировка всего списка
и т.п. Объявления (прототипы) этих функций приводятся в
заголовочном файле, причем на данном уровне в качестве
параметра функций или возвращаемого значения должен фигурировать
только указатель на базовую структуру или указатель на структуру
списка. Реализация этих и специфических функций выполняется в
файле модуля.

Фабричная функция должна создавать объект того типа, который
соответствует переданному в качестве параметра идентификатору
типа, папример:

  struct Base * Create(enum ItemType t)
  {
    struct Base * p = NULL;
    switch (t->type)
    {
      case itCat:
        p = malloc(sizeof(struct Cat));
        break;
      case itDog:  /* аналогично */
        ...
    }
    if (p)
      p->type = t; /* обязательно, иначе мы потом никогда не
                      узнаем, что это был за объект */
    return p;
  }

Операции над объектами реализуются в виде функций, которые
получают в качестве параметра указатель на объект. Если эта
операция должна выполняться различным образом для объектов разных
типов, то функция должна осуществлять диспетчеризацию, вызывая
соответствующую специфическую функцию. Например, вывод полей
объекта на экран выполняется по-разному для объектов разных типов,
так как они имеют различные наборы полей. Поэтому функция Print
должна реализовывать диспетчеризацию:

  void Print(struct Base * p)
  {
    if (p)
      switch (p->type)
      {
        case itCat:
          PrintCat((struct Cat *)p);
          break;
        case itDog:
          PrintDog((struct Dog *)p);
          break;
        case itCrocodile:
          PrintCrocodile((struct Crocodile *)p);
          break;
        defaul:
          printf("ERROR: object type unknown!\n");
      }
    else
      printf("ERROR: null pointer!\n");
  }

Функции PrintCat, PrintDog и PrintCrocodile являются специфическими
и для каждого типа объекта реализованы своим образом, например:

  void PrintCat(struct Cat * p)
  {
    printf("Cat:\n");
    printf("\tNick: %s\n\tAge: %d\n", p->nick, p->age);
    printf("\tWool: %d\n\tFurage: %s\n\tColour: %s\n", 
                                   p->wool, p->furage, p->colour);
  }

Аналогично будут реализованы оставшиеся две функции.

Функция печати всего списка объектов будет иметь вид:

  void PrintList(struct List * L)
  {
    struct Item * p;
    if (L)
      if (L->head)
        for (p = L->head; p; p = p->next)
          Print((struct Base *)p);
      else
        printf("List is empty.\n");
    else
      printf("ERROR: wrong list!\n);
  }

Во многих случаях значениям перечисления соответствуют некоторые
названия, которые требуется выводить в виде текста. Например, при
организации меню для выбора типа объекта или при печати содержимого
объекта (альтернатива примеру выше). В подобных случаях удобно
"продублировать" перечисление массивом строк, например:

  enum ItemType { itNone, itCat, itDog, itCrocodile };
  const char * const TypeName[] = 
            { "(unknown)", "Cat", "Dog", "Crocodile" };

Тогда вывод типа объекта можно унифицировать и выполнять не в
специфических функциях, а в общей функции Print(Base * p):

  printf("%s:\n", TypeName[p->type]);

Однако, значение поля type может оказаться неправильным (и не
только нулевым, а произвольным), что приведет к выводу на экран
"мусора" вместо названия или сообщения об ошибке. Поэтому его
необходимо проверить на принадлежность допустимому диапазону,
например так:

  printf("%s:\n", (p->type > 0 && p->type <= 3) ? 
      TypeName[p->type] : "unknown object!");

Т.е. если тип указан неправильно, будет выведено соответствующее
сообщение, но учитывая, что аналогичная строка соответствует
значению 0 (itNone в перечислении), можно сделать интереснее:

  printf("%s:\n", TypeName[(p->type>0 && p->type<=3)?p->type]:0);

Очевидно, что от варианта default в следующем за этим операторе
switch можно отказаться, чтобы не дублировать сообщение о
неизвестном типе объекта.
Далее можно реализовать функцию, которая используя тот же массив
строк и количество элементов в нем будет выводить меню, нумеруя
пункты, запрашивать ввод номера у пользователя и возвращать
полученное значение, например:

  int DoMenu(char * s[], int max)
  {
    int i = 0;
    for (i = 1; i <= max; i++)
      printf("%d. %s\n", i, s[i]);
    printf(">");
    fflush(stdin);
    scanf("%d", &i);
    return i<1||i>max?0:i;
  }

Остается только вызвать эту функцию, например, для выбора операции
в главной функции, для выбора типа объекта при его добавлении в
список и др.:

  enum ItemType { itNone, itCat, itDog, itCrocodile };
  const char * const TypeName[] = 
            { "(unknown)", "Cat", "Dog", "Crocodile" };

  const char * const Menu[11] =
            { "(none)", "Add", "Print list", "Count", ..., "Exit" };

  void main(void)
  {
    struct List L = {NULL, NULL};
    struct Base * p;
    enum ItemType t;
    int k;
    ...
    do
    {
      k = DoMenu(Menu, 10);    /* main menu */
      switch (k)
      {
        case 1: /* Add */
          t = DoMenu(TypeName, 3);  /* select object type */
          p = Create(t);
          Input(p);
          Add(&L, (struct Item * )p);
          break;
    ...

Аналогично можно поступить, если какое-либо поле может принимать
одно значение из некоторого множества допустимых значений -
создать перечисление и массив строк, так же осуществлять вывод
значений, а для вывода меню можно использовать ТУ ЖЕ функцию
DoMenu, т.к. она универсальна (только следует учитывать, что
вариант 0 в такой реализации не задействован!).
