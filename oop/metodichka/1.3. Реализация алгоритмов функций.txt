Учитывая, что поиск элемента в списке, когда это необходимо,
будет выполняться при помощи функции GetItem, алгоритмы всех
функций можно разделить на две группы: не циклические
(функции Add, Delete, Insert, Remove) и циклические
(функции GetItem, Count, GetIndex, Clear).

К реализации алгоритмов функций первой группы необходимо
подходить индивидуально. В каждом случае рекомендуется
графически изобразить состояние списка до выполнения функции
и после, обозначив типы и имена объектов, их поля, указав
связи между элементами и т.п. Затем следует сравнить
полученные диаграммы и выявить необходимые действия,
например какое значение какого поля какого объекта чему
присваивается и т.п. После составления общего алгоритма
функции следует рассмотреть частные случаи (неправильные
значения параметров, пустой список, действия над первым и
последним элементами списка, операции за пределами списка).
В каждом случае необходимо учитывать значения указателей
(равен NULL или нет), выявить пригодность или непригодность
общего решения и, в зависимости от этого, доработать
алгоритм с учетом частных случаев.

Например, фанкция Add должна добавить в список элемент.
Назовем его "новый" и допустим, что p - это указатель на
него, переданный в качестве параметра. Новый элемент
добавляется в "хвост", т.е. следом за последним элементом.
Общий алгоритм будет иметь следующий вид:
1) предыдущим для нового будет последний (т.е. поле prev
   нового должно содержать указатель на последний)
2) следующего элемента за новым нет, т.к. добавление
   происходит в "хвост" (следовательно поле next нового
   должно содержать нулевой указатель)
3) следующим для последнего будет новый (аналогично п.2)
4) новый становится последним (т.е. "хвост" списка содержит
   указатель на него)

Единственное исключение из этого алгоритма - добавление
элемента в пустой список, т.е. в список, который не содержит
ни одного элемента, следовательно, поля head и tail объекта
структуры List содержат нулевые указатели. В этом случае
новый элемент не имеет ни предыдущего, ни следующего за ним
элемента (аналогично п.2 выше) и является одновременно и
первым, и последним элементом списка (аналогично п.4 выше).
Получив общее решение на языке C в соответсвии с приведенным
выше алгоритмом, необходимо каждую конструкцию (т.е. каждый
оператор или выражение, соответствующие пунктам приведенного
алгоритма) проверить на корректность в частных ситуациях,
подставив характерные для этих ситуаций значения в выражения.
Например, п.2 и п.4 корректны и для пустого списка, а
корректность п.1 и п.3 необходимо установить самостоятельно.

Кроме того, при реализации этой операции следует учесть, что
входные данные могут быть неправильными (нулевые указатели).
Таким образом, полный алгоритм функции Add будет следующим:
1) если указатель на список равен нулю или указатель на
   элемент равен нулю (т.е. некуда или нечего добавлять), то
   завершить алгоритм
2) если список пуст, то (...), иначе выполнить приведенный
   выше алгоритм
При реализации п.2 можно те операции, которые являются общими
для обоих ветвей алгоритма, вынести за пределы условной
конструкции, что приведет к сокращению размера программы.

---------+---------+---------+---------+---------+---------+
/* продолжение следует */
